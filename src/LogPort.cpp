#include "LogPort.hpp"

LogPort::LogPort(const std::string& name, pocolog_cpp::InputDataStream& inputDataStream)
    : name(name)
    , inputDataStream(inputDataStream)
{
}

bool LogPort::replaySample(uint64_t sampleInStream)
{    
    if(!loggingActive)
    {
        return false;
    }    
    
    if(!port->connected())
    {
        return true;
    }
    
    std::vector<uint8_t> data;
    if(!inputDataStream.getSampleData(data, sampleInStream))
    {
        std::cout << "Warning, could not replay sample: " << inputDataStream.getName() << " " << sampleInStream <<  std::endl;
        return false;
    }
    
    try
    {
        transport->unmarshal(data, transportHandle);
    }
    catch (...)
    {
        std::cout << "caught marshall error.." << std::endl;
        return false;
    }
    
    // currently we're only supporting default states
//     if(port->getName() == "state")
//     {
//         switch(std::stoi(sample.get()->toString()))
//         {
//             case 0:  // INIT
//                 task->configure();
//                 break;
//             case 1:  // PRE_OPERATIONAL
//                 break;
//             case 2: // FATAL_ERROR
//                 break;
//             case 3: // EXCEPTION
//                 break;
//             case 4: // STOPPED
//                 task->stop();
//                 break;
//             case 5: // RUNNING
//                 task->start();
//                 break;
//             case 6:  // RUNTIME_ERROR
//                 break;
//             default:
//                 task->start();
//         }
//     }
    
    port->write(sample);
    
    return true;
}

bool LogPort::initialize(RTT::TaskContext& parentTask)
{
    RTT::types::TypeInfoRepository::shared_ptr ti = RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type(inputDataStream.getCXXType());
    if(!type)
    {
        std::cerr << "cannot find " << inputDataStream.getCXXType() << " in the type info repository" << std::endl;
        return false;
    }
    
    if(parentTask.getPort(name))
    {
        std::cerr << "port with name " << name << " already exists" << std::endl;
        return false;
    }
    
    RTT::base::OutputPortInterface *writer= type->outputPort(name);
    auto typekitTransport = dynamic_cast<orogen_transports::TypelibMarshallerBase*>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if(!typekitTransport)
    {
        log(RTT::Error) << "cannot report ports of type " << type->getTypeName() << " as no typekit generated by orogen defines it" << RTT::endlog();
        return false;
    }

    //TODO check if local type is same as logfile type
    
//     m_registry->merge(transport->getRegistry());
//     if (! m_registry->has(transport->getMarshallingType()))
//     {
//         log(RTT::Error) << "cannot report ports of type " << type->getTypeName() << " as I can't find a typekit Typelib registry that defines it" << RTT::endlog();
//         return false;
//     }

    
    try
    {
        port = writer;
        transportHandle = typekitTransport->createSample();
        transport = typekitTransport;
        sample = typekitTransport->getDataSource(transportHandle);
        loggingActive = true;
    } 
    catch(const RTT::internal::bad_assignment& ba)
    {
        return false;
    }
    
    parentTask.ports()->addPort(writer->getName(), *writer);
    
    std::cout << "added port " << writer->getName() << " on index " << inputDataStream.getIndex() << std::endl;
    
    return true;
}



